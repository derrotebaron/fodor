require_relative "optimizer"

# This class can be used to construct {Optimizer}s based on the genetic algorithm.
# There are a few "variables" for controlling the behavior of this class.
#
# (TODO This could be refactored to make this more flexible)
#
# The following aspects can be specified by the user:
# 1. The population size.
# 2. The selection algorithm can be defined by a Proc reciving the following
# parameters: the results array and a random object.
# 3. The number of genotypes to be constructed by the crossover operation.
# 4. The probability for the crossover operation to "switch sides", for more on
# this, see the crossover description in the folloing paragraphs.
# 5. The number of genotypes to be constructed by the mutation operation.
# 6. The probability for the mutation operation to change a flag.
#
# The algorithm works as follows:
# The population gets randomly generated in the beginning. Then the
# select-repopulate-loop starts. The population gets new members with the
# crossover and mutation opertion.
#
# The crossover algorithm takes "genes" from one genotype and adds it to the
# result and continues to do so until it randomly switches sides and from then on takes from the other side again.
# The mutation algorithm goes over all "genes" and according to some probability chooses to change some to a random value.
#
# After that the user provided selection function reduces the population to a reasonable number.
class GeneticOptimizer < Optimizer
  include LoggedClass
  # Returns a new generation based Optimizer.
  # @param name [String] Name of the Algorithm.
  # @param seed [Fixnum] The seed for the random generator.
  # @param evaluator [Evaluator] The Evaluator to use.
  # @param select [Proc] The selection function.
  # @param crossovers [Fixnum] The number of genotypes to be generated by the crossover operation.
  # @param crossover_probability [Float] The probability for the crossover operation to "switch sides". See the {GeneticOptimizer class documentation} for more on this.
  # @param mutations [Fixnum] The number of genotypes to be generated by the mutation operation.
  # @param mutation_probability [Float] The probability for the mutation operation to change an element of a candidate.
  # @param termination_criterion [Proc] The termination criterion.
  # @param flag_set [FlagSet] The flag set to use.
  # @param load_state_filename [String] The name of a file to load the state from.
  def initialize(name, seed, evaluator, population_size, select,
                 crossovers, crossover_probability,
                 mutations, mutation_probability,
                 termination_criterion, flag_set, load_state_filename = nil)
    super name, seed, evaluator, load_state_filename
    @population_size, @flag_set = population_size, flag_set
    @select, @termination_criterion = select, termination_criterion
    @crossovers, @mutations = crossovers, mutations
    @crossover_probability = crossover_probability
    @mutation_probability = mutation_probability
    @genotypes = []
  end

  # @private
  def step()
    if @steps.zero? then
      @genotypes, = (OptimizerUtils.get_init OptimizerUtils.get_init_mutate,
                                             @population_size,
                                             @flag_set)[@genotypes,
                                                        @results,
                                                        @random, nil]
    end

    @genotypes = repopulate @genotypes

    # evaluate genotypes
    @results << (@evaluator[@genotypes].zip (@genotypes.map do |genotype|
      genotype.dup
    end))

    # increment step-counter
    @steps += 1
    @evaluator.step

    @genotypes = @select[@results, @random]

    raise OptimizerCompleteSignal if @termination_criterion[@steps, @results]
  end

  # @private
  def repopulate(genotypes)
    previous_genotypes = genotypes.dup
    crossover_genotypes = []

    @crossovers.times do
      # select random pairs and crossover them
      candidate = crossover(*(previous_genotypes.
                              shuffle(random: @random)[0..1]),
                              @crossover_probability)
      while crossover_genotypes.include? candidate do
        candidate = crossover(*(previous_genotypes.
                                shuffle(random: @random)[0..1]),
                                @crossover_probability)
      end
      crossover_genotypes << candidate
    end

    mutation_genotypes = previous_genotypes[0...@mutations].map do |genotype|
      mutate genotype, @mutation_probability
    end

    crossover_genotypes + mutation_genotypes + previous_genotypes
  end


  # @private
  def crossover(geno1, geno2, prob)
    # iterate over all components
    geno_new = geno1.dup
    select_first = false

    geno2.each_with_index do |flag, idx|
      if @random.rand <= prob then
        select_first = !select_first
      end
      geno_new[idx] = flag[:value] unless select_first
    end

    debug "Genetic: crossover 1 #{geno1.show_binstring}\n" +
      "Genetic: crossover 2 #{geno2.show_binstring}\n" +
      "Genetic: crossover = #{geno_new.show_binstring}"
    geno_new
  end

  # @private
  def mutate(geno, prob)
    geno = geno.dup

    geno.each_with_index do |flag, idx|
      if @random.rand <= prob then
        debug "Genetic: Mutating #{flag}"
        geno[idx] = flag[:flag].pick(@random)
      end
    end

    geno
  end

  # @private
  def save_state(filename)
    File.open(filename, "w") do |file|
      file.write (Marshal.dump [:genetic, @steps, @results,
                                @genotypes, @random])
    end
  end

  # @private
  def load_state(filename)
    File.open(filename, "r") do |file|
      _, @steps, @results, @genotypes, @random = Marshal.restore @file.read
    end
  end
end
